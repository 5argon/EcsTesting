using System;
using Unity.Collections;
using Unity.Entities;

namespace E7.EcsTesting
{
    /// <summary>
    /// Performs higher level, one-off operation on <see cref="EntityManager"/>.
    /// Many methods allocate and immediately dispose <see cref="EntityQuery"/> inside each call.
    ///
    /// This system independent shortcuts are useful for unit testing so you can query and check in one line.
    ///
    /// There is no `CompleteAllJobs` inside. There is a chance that it would cause
    /// error when someone else is reading/writing the same data.
    /// </summary>
    public partial class EntityAssertionQuery
    {
        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public SCD1 GetSingle<SCD1>(SCD1 filter1)
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                using (var ea = eq.ToEntityArray(Allocator.TempJob))
                {
                    if (ea.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {ea.Length}.");
                    }

                    return em.GetSharedComponentData<SCD1>(ea[0]);
                }
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<SCD1>(SCD1 filter1)
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<SCD1>(filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<SCD1>(SCD1 filter1)
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<SCD1>(SCD1 filter1)
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public SCD1 GetSingle<SCD1>(bool nf)
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                using (var ea = eq.ToEntityArray(Allocator.TempJob))
                {
                    if (ea.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {ea.Length}.");
                    }

                    return em.GetSharedComponentData<SCD1>(ea[0]);
                }
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<SCD1>(bool nf)
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<SCD1>(nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<SCD1>(bool nf)
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<SCD1>(bool nf)
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public SCD1 GetSingle<SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                using (var ea = eq.ToEntityArray(Allocator.TempJob))
                {
                    if (ea.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {ea.Length}.");
                    }

                    return em.GetSharedComponentData<SCD1>(ea[0]);
                }
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<SCD1, SCD2>(filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public SCD1 GetSingle<SCD1, SCD2>(bool nf1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                using (var ea = eq.ToEntityArray(Allocator.TempJob))
                {
                    if (ea.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {ea.Length}.");
                    }

                    return em.GetSharedComponentData<SCD1>(ea[0]);
                }
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<SCD1, SCD2>(bool nf1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<SCD1, SCD2>(nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<SCD1, SCD2>(bool nf1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<SCD1, SCD2>(bool nf1, SCD2 filter2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public SCD1 GetSingle<SCD1, SCD2>(bool nf1, bool nf2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                using (var ea = eq.ToEntityArray(Allocator.TempJob))
                {
                    if (ea.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {ea.Length}.");
                    }

                    return em.GetSharedComponentData<SCD1>(ea[0]);
                }
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<SCD1, SCD2>(bool nf1, bool nf2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<SCD1, SCD2>(nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<SCD1, SCD2>(bool nf1, bool nf2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<SCD1, SCD2>(bool nf1, bool nf2)
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1>()
            where CD1 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1>()
            where CD1 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1>()
            where CD1 : struct, IComponentData
        {
            var ea = Entities<CD1>();
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1>()
            where CD1 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1>()
            where CD1 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
        {
            var ea = Entities<CD1>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1>(filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1>(nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1, SCD2>(filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1, SCD2>(nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1, SCD2>(nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2>();
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1>(filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1>(nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3>();
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4>();
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5>();
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, CD4, CD5, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, CD4, CD5, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5>(Func<CD1, CD2, CD3, CD4, CD5, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, CD6>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, CD6>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6>();
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6>()
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, CD5, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, CD5, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, CD5, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6>(where);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where,
            SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, filter1);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where,
            SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where,
            SCD1 filter1)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                eq.SetSharedComponentFilter(filter1);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(where, nf);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where,
            bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where,
            bool nf)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// The first type is always the returning value.
        /// </summary>
        public CD1 GetSingle<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                using (var cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    if (cda.Length != 1)
                    {
                        throw new System.InvalidOperationException(
                            $"GetSingle() requires that exactly one exists but there are {cda.Length}.");
                    }

                    return cda[0];
                }
            }
        }


        /// <summary>
        /// Return a linearized component data array of the first component of generic type arguments.
        /// You can add additional components upto 6 CD and upto 2 SCD types to the query.
        /// </summary>
        public CD1[] Components<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToComponentDataArray<CD1>(Allocator.TempJob);
                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, SCD1 filter1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where, bool nf1,
            bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, filter1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where,
            SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, SCD1 filter1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter1, filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, filter2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where,
            bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, bool nf1, SCD2 filter2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                eq.SetSharedComponentFilter(filter2);
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }


        /// <summary>
        /// Perform a query that should result in only one result and return it.
        /// If it returns 0 or more than 1, it is considered a failing test.
        /// 
        /// You can add upto 0~6 CD and 0~2 SCD types to the query and also where filter
        /// based on any of the CD. Query, SCD filter, and where filter combined must
        /// produce 1 entity. Automatically throws if it wasn't, which is useful in tests.
        /// </summary>
        public Entity GetSingleEntity<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            var ea = Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(where, nf1, nf2);
            if (ea.Length != 1)
            {
                throw new System.InvalidOperationException(
                    $"GetSingleEntity() requires that exactly one exists but there are {ea.Length}.");
            }

            return ea[0];
        }


        /// <summary>
        /// Count entities that are returned from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public int EntityCount<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where,
            bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                int count = na.Length;
                na.Dispose();
                return count;
            }
        }


        /// <summary>
        /// Return a linearized entity array from All query made of all components on generic type arguments.
        /// You can add upto 0~6 CD and 0~2 SCD types to the query.
        /// </summary>
        /// <remarks>
        /// In the argument :
        /// 
        /// - Add a lambda with input argument typed the same as component data specified
        /// in the generic type argument. This is a filter to only work on an entity that
        /// pass the criteria. (Like LINQ's `.Where`) It is possible to specify just a subset
        /// of all component data in the generic type as long as the omitted types come later
        /// when counting from left to right.
        /// 
        /// - Add from 0 to 2 SCD value filter, if you have enough SCD generic type specified.
        /// Use `nf: false` in place of actual value to skip filtering that SCD type.
        /// With that it is possible to use SCD types as one of tag components.
        /// </remarks>
        public Entity[] Entities<CD1, CD2, CD3, CD4, CD5, CD6, SCD1, SCD2>(
            Func<CD1, CD2, CD3, CD4, CD5, CD6, bool> where, bool nf1, bool nf2)
            where CD1 : struct, IComponentData
            where CD2 : struct, IComponentData
            where CD3 : struct, IComponentData
            where CD4 : struct, IComponentData
            where CD5 : struct, IComponentData
            where CD6 : struct, IComponentData
            where SCD1 : struct, ISharedComponentData
            where SCD2 : struct, ISharedComponentData
        {
            using (var eq = em.CreateEntityQuery(
                ComponentType.ReadOnly<CD1>(),
                ComponentType.ReadOnly<CD2>(),
                ComponentType.ReadOnly<CD3>(),
                ComponentType.ReadOnly<CD4>(),
                ComponentType.ReadOnly<CD5>(),
                ComponentType.ReadOnly<CD6>(),
                ComponentType.ReadOnly<SCD1>(),
                ComponentType.ReadOnly<SCD2>()
            ))
            {
                var na = eq.ToEntityArray(Allocator.TempJob);

                NativeList<Entity> filtered = new NativeList<Entity>(na.Length, Allocator.Temp);
                using (var cd1Cda = eq.ToComponentDataArray<CD1>(Allocator.TempJob))
                using (var cd2Cda = eq.ToComponentDataArray<CD2>(Allocator.TempJob))
                using (var cd3Cda = eq.ToComponentDataArray<CD3>(Allocator.TempJob))
                using (var cd4Cda = eq.ToComponentDataArray<CD4>(Allocator.TempJob))
                using (var cd5Cda = eq.ToComponentDataArray<CD5>(Allocator.TempJob))
                using (var cd6Cda = eq.ToComponentDataArray<CD6>(Allocator.TempJob))
                {
                    for (int i = 0; i < na.Length; i++)
                    {
                        if (where(cd1Cda[i], cd2Cda[i], cd3Cda[i], cd4Cda[i], cd5Cda[i], cd6Cda[i]))
                        {
                            filtered.Add(na[i]);
                        }
                    }
                }

                na.Dispose();
                na = new NativeArray<Entity>(filtered.Length, Allocator.Temp);
                for (int i = 0; i < filtered.Length; i++)
                {
                    na[i] = filtered[i];
                }

                filtered.Dispose();

                var array = na.ToArray();
                na.Dispose();
                return array;
            }
        }
    }
}